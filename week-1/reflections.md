# 1.1 Think About Time Reflection
I learned about several productivity and time management tactics that I'm itching to test out - such as meditation, emotional awareness, and starting small.  The big takeaway I had from looking through the wide range of topics is that there can be great benefits (to mood and productivity) from implementing small habits.  Even a couple minutes of meditation a day can result in improved focus, memory, and creativity throughout the day.  Similarly, focusing on one small task at a time can help you stay focused and find more enjoyment in day-to-day work.  

One of my favorite quotes that I took away from the reading is "confidence is displayed ability".  I had always heard of the mantra "fake it till you become it", but that never really clicked with me until realizing that confidence is just the ability to produce a correct action.  I know that this will be a very important lesson for me as I go into the bootcamp as well as the software industry, as there will be many things that I won't know.  I'll be able to rely on acting like a "professional developer" by following various best practices for development and writing good code.  

Time boxing is setting aside a static amount of time to achieve a given goal and then evaluating progress at the end of the time.  For example, you can assign yourself the task of completing a homework assignment in 25 minutes and not allow any further work once the time has elapsed.  This helps by focusing your attention on a single task and can produce work that is "good enough" rather than perfect, which isn't necessarily a bad thing in the realm of software development.  I currently employ the pomodoro method as a means for estimating how long a given task will take as well as measuring my overall productivity day-to-day and week-to-week.  It works well as a benchmark, however, there are other strategies I can include as part of my workflow that may improve my productivity.

I intend to further use time boxing and set aside a short period of time every morning and evening to due some quick meditation.  I will use this in conjunction with the pomodoro method to determine whether this has a positive effect on my productivity and mood.  I will also have a greater emphasis on explicitly writing out tasks to accomplish and giving myself a set amount of pomodoros to complete the task.  I will then review my progress at the end of the session.  My hope is that this will give me increased focus during the fixed timebox and allow me to complete more work.  My overall plan is to give myself a set number of hours to complete phase 0 material and try to achieve my goals each week.  

# 1.2 The Command Line Reflection
1. A shell is a command-line interpreter and is an interface to the system in question.  Bash is the "Bourne Again Shell", which is just one of many command-line interpreters.  Bash has a compilation of features from other shells such as sh, csh, and ksh.
2. The most challenging piece going through this material was learning some of the more advanced features of unix and using them coherently.  Piping, regular expressions, and scripting sounds simple at the outset but it takes a lot of practice to get it down fluently.  Similarly, keyboard shortcuts (such as use of vi commands at the shell prompt) are hard to get used to.
3. I was successfully able to use all of the base commands.  I haven't yet built fluency with all of the different options to the various commands.
4. I think the most important commands to know are those that let you move around your system and edit/execute files.  A short list would be cd, pwd, ls -l, vi <filename>, ./<executable>.
5. Various commands and what they do:
  * pwd - prints out the path of your current working directory.  You generally use this command to remind yourself where you are in the system (mostly to get the full path in a format you can pipe or copy since most people have the current working directory in their prompt).
  * ls - Lists out the files in the current working directory.  There are some very useful options to this command.  The option "-l" gives you important information about the files/directories in your current directory, including things like permissions and last-access time.  You can also view "hidden" files with "ls -a" to view things like your .bash_profile.  You are also able to pass in a given directory so that you do not have to move into a directory with "cd" first.
  * mv - Allows you to move a file to another location or to a new name.  Note that this is different from the "cp" command, which also keeps your initial file.  
  * cd - This lets you change your directory to a directory of your choosing.
../ - This represents the directory "above" your current directory.  If you were in /users/kevin/test you could type "cd .." or "cd ../" and go up to the directory "/users/kevin".
  * touch - This command allows you to create a new file for editing.  It can also update the last modification times of an existing file.
  * mkdir - This command allows you to make a new directory.  Some useful options, like -p, will allow you to create a chain of directories that may not already exist.
  * less - This allows you to view a file one page at a time.
  * rmdir - This command allows you to remove a directory.  Useful for cleaning up directory structures that you no longer need.
  * rm - This command allows you to remove files.  The useful (but DANGEROUS) option -r allows you to remove files recursively which can allow you to delete entire directory trees with a single command.
  * help - displays help information for the given command.

# 1.4 Forking and Cloning Reflection
To create a new repository, simply go to github and click on the "Create new...">"New Repository" button near the top right of the screen.  Once you have located a repo that you would like to fork, you can simply click on the "fork" button to create a fork of the repo.  You can find the HTTPS clone url on that page.  Grab a copy of the url and enter "git clone <url>" at the command line in order to clone the repo.  You could also clone the repository from the GitHub GUI tool if you so choose.  The advantage of forking a repository is so that you can have your own personal version of the repository that you can work on and make updates to.  You can also send a request to update the main repository via a pull request.   You can make commits via git on the local repository that you have cloned.  You can make updates to various files (or add new files) and then commit those changes to the repository.  This will create a new revision with those changes so that the change-history can be documented over time.

I struggled with understanding how git and GitHub are tied together.  I was able to successfully clone the repository to my machine, however, I didn't have a clear understanding of how branches on git could tie into GitHub.  Through creating a branch and submitting a pull request to the master, I was able to form a better understanding of the relationship between git and GitHub.  The overall workflow of creating a new branch, committing changes, an submitting a pull request makes a lot more sense to me as a standard way of making changes safely.  
